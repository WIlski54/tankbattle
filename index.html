<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Panzer Duell</title>
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Canvas und Kontext einrichten ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Assets ---
        const playerImage = new Image(); playerImage.src = 'tank.png';
        const aiImage = new Image(); aiImage.src = 'tank.png';
        const titleImage = new Image(); titleImage.src = 'titel.png';
        const barrelImage = new Image(); barrelImage.src = 'fass.png';
        const victoryImage = new Image(); victoryImage.src = 'orden.png';
        const cargoImage = new Image(); cargoImage.src = 'cargo.png';
        const crateImage = new Image(); crateImage.src = 'nachschub.png';
        const shieldImage = new Image(); shieldImage.src = 'schild.png'; // NEU
        const shootSound = new Audio('fire.mp3');
        const soundtrack = new Audio('soundtrack.mp3'); soundtrack.loop = true;
        const boomSound = new Audio('boom.mp3');
        const victorySound = new Audio('orden_sound.mp3');
        const propellerSound = new Audio('propeller.mp3'); propellerSound.loop = true;
        const shieldHitSound = new Audio('treffer_schild.mp3'); // NEU

        // --- Spiel-Zustand & Steuerung ---
        let gameState = 'title_start';
        let TILE_SIZE = 40;
        let projectiles = [], obstacles = [], player, ai;
        let selectedDifficultyKey = 'hauptmann';
        let audioUnlocked = false; 
        let currentLevelIndex = 0;
        const keys = { w: false, s: false, a: false, d: false, space: false };
        const mouse = { x: 0, y: 0, hoverButton: null };
        let wallTextures = new Map();
        let explosiveBarrel = null;
        let particles = [];
        let explosions = [];
        let barrelRespawnTimer = 0;
        const BARREL_RESPAWN_TIME = 900;
        let pathfindingGrid = [];

        let cargoPlane = null;
        let supplyCrate = null;
        let planeFlyByTimer = 2700;
        const PLANE_FLYBY_INTERVAL = 2700;

        let animationStartTime = 0;
        const animationDuration = 1500;

        window.addEventListener('keydown', (e) => { if(keys[e.key.toLowerCase()] !== undefined) keys[e.key.toLowerCase()] = true; if(e.key === ' ') keys.space = true; });
        window.addEventListener('keyup', (e) => { if(keys[e.key.toLowerCase()] !== undefined) keys[e.key.toLowerCase()] = false; if(e.key === ' ') keys.space = false; });
        canvas.addEventListener('click', handleMouseClick);
        canvas.addEventListener('mousemove', handleMouseMove);

        const difficulties = {
            gefreiter: { name: 'Gefreiter', speed: 1.6, rotationSpeed: 2.0, shootCooldown: 60, accuracyError: 10, color: '#a5d6a7', aggressiveness: 0.3, predictionFactor: 0, reactionTime: 30 },
            hauptmann: { name: 'Hauptmann', speed: 2.2, rotationSpeed: 3.0, shootCooldown: 35, accuracyError: 3, color: '#ffee58', aggressiveness: 0.7, predictionFactor: 0.3, reactionTime: 15 },
            general: { name: 'General', speed: 2.5, rotationSpeed: 3.5, shootCooldown: 20, accuracyError: 0.5, color: '#ef5350', aggressiveness: 1.0, predictionFactor: 0.6, reactionTime: 5 }
        };
        const difficultyButtons = [];
        const startButton = { x:0, y:0, w: 250, h: 70, text: "Spiel starten" };

        class Particle { constructor(x, y, type = 'fire', color = null) { this.x = x; this.y = y; this.type = type; const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 8 + 2; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.life = 1.0; this.decay = Math.random() * 0.02 + 0.01; this.size = Math.random() * 8 + 4; this.color = color; if (type === 'smoke') { this.vx *= 0.3; this.vy *= 0.3; this.vy -= Math.random() * 2; this.decay = 0.008; this.size = Math.random() * 15 + 10; } else if (type === 'debris') { this.vy += Math.random() * -5; this.gravity = 0.5; this.rotation = Math.random() * Math.PI * 2; this.rotationSpeed = (Math.random() - 0.5) * 0.3; } else if (type === 'spark') { this.decay = 0.05; } } update() { this.x += this.vx; this.y += this.vy; this.life -= this.decay; if (this.type === 'fire' || this.type === 'spark') { this.vx *= 0.98; this.vy *= 0.98; this.size *= 0.97; } else if (this.type === 'smoke') { this.size *= 1.02; } else if (this.type === 'debris') { this.vy += this.gravity; this.rotation += this.rotationSpeed; } return this.life > 0; } draw() { ctx.save(); if (this.type === 'spark') { ctx.fillStyle = this.color || `rgba(173, 216, 230, ${this.life})`; ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size); } else if (this.type === 'fire') { const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); gradient.addColorStop(0, `rgba(255, 255, 255, ${this.life})`); gradient.addColorStop(0.4, `rgba(255, 200, 0, ${this.life})`); gradient.addColorStop(0.7, `rgba(255, 100, 0, ${this.life})`); gradient.addColorStop(1, `rgba(255, 0, 0, 0)`); ctx.fillStyle = gradient; ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2); } else if (this.type === 'smoke') { ctx.globalAlpha = this.life * 0.4; ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); } else if (this.type === 'debris') { ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.fillStyle = `rgba(139, 69, 19, ${this.life})`; ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size); } ctx.restore(); } }
        class Explosion { constructor(x, y) { this.x = x; this.y = y; this.shockwaveRadius = 0; this.maxRadius = 150; this.active = true; } update() { this.shockwaveRadius += 8; if (this.shockwaveRadius > this.maxRadius) this.active = false; } draw() { ctx.save(); ctx.globalAlpha = 1 - (this.shockwaveRadius / this.maxRadius); ctx.strokeStyle = '#FFA500'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(this.x, this.y, this.shockwaveRadius, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = (1 - (this.shockwaveRadius / this.maxRadius)) * 0.3; ctx.fillStyle = '#FF6600'; ctx.fill(); ctx.restore(); } }
        class PathNode { constructor(x, y, parent = null) { this.x = x; this.y = y; this.parent = parent; this.gCost = 0; this.hCost = 0; this.fCost = 0; } }
        function findPath(grid, startCoords, endCoords) { const startNode = new PathNode(startCoords.x, startCoords.y), endNode = new PathNode(endCoords.x, endCoords.y); const openList = [startNode], closedList = new Set(); while (openList.length > 0) { let currentNode = openList[0]; for (let i = 1; i < openList.length; i++) if (openList[i].fCost < currentNode.fCost || (openList[i].fCost === currentNode.fCost && openList[i].hCost < currentNode.hCost)) currentNode = openList[i]; openList.splice(openList.indexOf(currentNode), 1); closedList.add(`${currentNode.x},${currentNode.y}`); if (currentNode.x === endNode.x && currentNode.y === endNode.y) { const path = []; let current = currentNode; while (current !== null) { path.push({ x: current.x, y: current.y }); current = current.parent; } return path.reverse(); } for (let x = -1; x <= 1; x++) for (let y = -1; y <= 1; y++) { if (x === 0 && y === 0) continue; const checkX = currentNode.x + x, checkY = currentNode.y + y; if (checkX >= 0 && checkX < grid[0].length && checkY >= 0 && checkY < grid.length && grid[checkY][checkX] === 0 && !closedList.has(`${checkX},${checkY}`)) { if (x !== 0 && y !== 0 && (grid[checkY - y][checkX] !== 0 || grid[checkY][checkX - x] !== 0)) continue; const newGCost = currentNode.gCost + getDistance(currentNode, {x: checkX, y: checkY}); const existingNode = openList.find(n => n.x === checkX && n.y === checkY); if (existingNode === undefined || newGCost < existingNode.gCost) { const neighbor = existingNode || new PathNode(checkX, checkY); neighbor.parent = currentNode; neighbor.gCost = newGCost; neighbor.hCost = getDistance({x: checkX, y: checkY}, endNode); neighbor.fCost = neighbor.gCost + neighbor.hCost; if (existingNode === undefined) openList.push(neighbor); } } } } return null; }
        function getDistance(nodeA, nodeB) { const dstX = Math.abs(nodeA.x - nodeB.x), dstY = Math.abs(nodeA.y - nodeB.y); return (dstX > dstY) ? 14 * dstY + 10 * (dstX - dstY) : 14 * dstX + 10 * (dstY - dstX); }
        class Tank { constructor(x, y, type, difficultyKey) { this.x = x; this.y = y; this.type = type; this.difficulty = difficulties[difficultyKey]; this.width = 45; this.height = 45; this.angle = (type === 'player') ? 0 : 180; this.lives = 3; this.isHit = 0; this.image = (type === 'player') ? playerImage : aiImage; this.speed = (type === 'player') ? 2.2 : this.difficulty.speed; this.rotationSpeed = (type === 'player') ? 2.5 : this.difficulty.rotationSpeed; this.shootCooldownTime = (type === 'player') ? 20 : this.difficulty.shootCooldown; this.shootCooldown = 0; this.aiState = 'hunting'; this.lastPlayerPos = { x: 0, y: 0 }; this.stuckCounter = 0; this.lastPos = { x: x, y: y }; this.reactionTimer = 0; this.path = []; this.pathRecalculateTimer = 0; this.isDestroyed = false; this.shield = { active: false, timer: 0, maxTime: 900, scale: 0 }; } 
            update() { if (this.isDestroyed) return; if (this.isHit > 0) this.isHit--; if (this.shootCooldown > 0) this.shootCooldown--; if (this.shield.active) { this.shield.timer--; if (this.shield.timer <= 0) { this.shield.active = false; } if (this.shield.scale < 1) { this.shield.scale += 0.1; } } if (this.type === 'player') this.handlePlayerInput(); else this.updateAI(); this.handleScreenWrap(); } 
            handlePlayerInput() { if (keys.a) this.angle -= this.rotationSpeed; if (keys.d) this.angle += this.rotationSpeed; if (keys.w || keys.s) { const moveSpeed = keys.w ? this.speed : -this.speed * 0.7; const nextPos = this.calculateNextPosition(moveSpeed); if (!this.checkCollision(nextPos.x, nextPos.y)) { this.x = nextPos.x; this.y = nextPos.y; } } if (keys.space && this.shootCooldown === 0) this.shoot(); } 
            updateAI() { if (this.reactionTimer > 0) { this.reactionTimer--; return; } const target = player; if (!target || target.isDestroyed) return; if (supplyCrate && supplyCrate.state === 'landed') { const distanceToCrate = Math.hypot(supplyCrate.targetX - this.x, supplyCrate.targetY - this.y); const playerDistanceToCrate = Math.hypot(supplyCrate.targetX - target.x, supplyCrate.targetY - target.y); if (distanceToCrate < playerDistanceToCrate * 1.2) { this.aiState = 'seeking_crate'; } } const distanceToTarget = Math.hypot(target.x - this.x, target.y - this.y); const hasLineOfSight = this.checkLineOfSight(target); if (this.aiState !== 'seeking_crate') { if (hasLineOfSight && distanceToTarget < 600) { this.aiState = 'attacking'; this.lastPlayerPos = { x: target.x, y: target.y }; this.path = []; } else { const needsNewPath = this.path.length === 0 || this.pathRecalculateTimer <= 0; if (needsNewPath) this.recalculatePath(target); this.aiState = this.path.length > 0 ? 'following_path' : 'hunting'; } } switch(this.aiState) { case 'hunting': this.huntPlayer(target); break; case 'attacking': this.attackPlayer(target, distanceToTarget); break; case 'following_path': this.followPath(); break; case 'seeking_crate': if (!supplyCrate || supplyCrate.state !== 'landed') { this.aiState = 'hunting'; this.path = []; break; } if (this.path.length === 0 || this.pathRecalculateTimer <= 0) { this.recalculatePath(supplyCrate); } this.followPath(); break; } } 
            recalculatePath(target) { if (!pathfindingGrid || !target) return; const targetPos = target.targetX ? {x: target.targetX, y: target.targetY} : target; const startCoords = this.worldToGrid({ x: this.x, y: this.y }); const endCoords = this.worldToGrid(targetPos); if (!pathfindingGrid[endCoords.y] || pathfindingGrid[endCoords.y][endCoords.x] === 1) { this.path = []; return; } const newPath = findPath(pathfindingGrid, startCoords, endCoords); if (newPath) { this.path = newPath; this.path.shift(); } this.pathRecalculateTimer = 30; } 
            followPath() { if (this.path.length === 0) { this.aiState = 'hunting'; return; } const nextNode = this.path[0]; const targetPos = this.gridToWorld(nextNode); if (Math.hypot(targetPos.x - this.x, targetPos.y - this.y) < TILE_SIZE / 2) { this.path.shift(); if (this.path.length === 0) { this.aiState = 'hunting'; return; } } const angleToTarget = Math.atan2(targetPos.y - this.y, targetPos.x - this.x) * 180 / Math.PI + 90; this.aimAt(angleToTarget); const nextPos = this.calculateNextPosition(this.speed * this.difficulty.aggressiveness); if (!this.checkCollision(nextPos.x, nextPos.y)) { this.x = nextPos.x; this.y = nextPos.y; } } 
            huntPlayer(target) { if (!target) return; this.recalculatePath(target); this.followPath(); } 
            attackPlayer(target, distance) { let targetX = target.x, targetY = target.y; if (this.difficulty.predictionFactor > 0) { const dx = target.x - this.lastPlayerPos.x, dy = target.y - this.lastPlayerPos.y; const predictionDistance = distance / 6; targetX += dx * predictionDistance * this.difficulty.predictionFactor; targetY += dy * predictionDistance * this.difficulty.predictionFactor; } const error = (Math.random() - 0.5) * this.difficulty.accuracyError; const targetAngle = Math.atan2(targetY - this.y, targetX - this.x) * 180 / Math.PI + 90 + error; this.aimAt(targetAngle); if (this.isAimed(targetAngle, 5 + this.difficulty.accuracyError) && this.shootCooldown === 0) { this.shoot(); this.reactionTimer = this.difficulty.reactionTime; } } 
            activateShield() { this.shield.active = true; this.shield.timer = this.shield.maxTime; this.shield.scale = 0; for (let i = 0; i < 50; i++) { particles.push(new Particle(this.x, this.y, 'spark', `rgba(100, 180, 255, ${Math.random()})`)); } }
            hit() { if (this.shield.active) { if(audioUnlocked) shieldHitSound.cloneNode().play(); for (let i = 0; i < 5; i++) particles.push(new Particle(this.x, this.y, 'spark')); return; } if (this.isHit > 0 || this.isDestroyed) return; this.lives--; this.isHit = 30; if (this.lives <= 0) { this.isDestroyed = true; createTankExplosion(this.x, this.y); if (this.type === 'ai') { setTimeout(() => handleLevelAdvance(), 2500); } else { setTimeout(() => { gameState = 'gameOver'; }, 2500); } } } 
            draw() { if (this.isDestroyed) return; ctx.save(); if (this.isHit > 0 && this.isHit % 10 < 5) { ctx.globalAlpha = 0.5; } ctx.translate(this.x, this.y); ctx.rotate(this.angle * Math.PI / 180); const visualSize = this.width * 1.5; if (this.type === 'ai') { ctx.filter = 'hue-rotate(180deg) brightness(1.2)'; } ctx.drawImage(this.image, -visualSize / 2, -visualSize / 2, visualSize, visualSize); ctx.restore(); if (this.shield.active) { ctx.save(); const shieldSize = visualSize * 1.2 * this.shield.scale; if (this.shield.timer < 180 && this.shield.timer % 20 < 10) { ctx.globalAlpha = 0.5; } else { ctx.globalAlpha = 0.8; } ctx.translate(this.x, this.y); ctx.rotate((Date.now() / 1000) * 50 * Math.PI / 180); ctx.drawImage(shieldImage, -shieldSize / 2, -shieldSize / 2, shieldSize, shieldSize); ctx.restore(); } } 
            aimAt(targetAngle) { const angleDiff = (targetAngle - this.angle + 540) % 360 - 180; this.angle += Math.max(-this.rotationSpeed, Math.min(this.rotationSpeed, angleDiff)); } isAimed(targetAngle, tolerance = 5) { const angleDiff = Math.abs((targetAngle - this.angle + 540) % 360 - 180); return angleDiff < tolerance; } calculateNextPosition(speed, customAngle = null) { const angleToUse = customAngle !== null ? customAngle : this.angle; const angleRad = (angleToUse - 90) * Math.PI / 180; return { x: this.x + Math.cos(angleRad) * speed, y: this.y + Math.sin(angleRad) * speed }; } checkLineOfSight(target) { if (!target) return false; const dx = target.x - this.x, dy = target.y - this.y; const distance = Math.hypot(dx, dy); const steps = Math.floor(distance / 10); for(let i = 1; i < steps; i++){ const checkX = this.x + (dx/steps) * i, checkY = this.y + (dy/steps) * i; for(const o of obstacles) if(checkX > o.x && checkX < o.x + o.width && checkY > o.y && checkY < o.y + o.height) return false; } return true; } checkCollision(x, y) { for (const o of obstacles) if (x - this.width / 2 < o.x + o.width && x + this.width / 2 > o.x && y - this.height / 2 < o.y + o.height && y + this.height / 2 > o.y) return true; return false; } shoot() { this.shootCooldown = this.shootCooldownTime; if (audioUnlocked) shootSound.cloneNode().play(); const angleRad = (this.angle - 90) * Math.PI / 180; projectiles.push({ x: this.x, y: this.y, owner: this.type, dx: Math.cos(angleRad) * 6, dy: Math.sin(angleRad) * 6 }); } handleScreenWrap() { const buffer = this.width; if (this.x < -buffer) this.x = canvas.width + buffer; if (this.x > canvas.width + buffer) this.x = -buffer; if (this.y < -buffer) this.y = canvas.height + buffer; if (this.y > canvas.height + buffer) this.y = -buffer; } worldToGrid(worldPos) { const map = levelMaps[currentLevelIndex]; const offsetX = (canvas.width - map[0].length * TILE_SIZE) / 2, offsetY = (canvas.height - map.length * TILE_SIZE) / 2; const gridX = Math.floor((worldPos.x - offsetX) / TILE_SIZE), gridY = Math.floor((worldPos.y - offsetY) / TILE_SIZE); return { x: gridX, y: gridY }; } gridToWorld(gridPos) { const map = levelMaps[currentLevelIndex]; const offsetX = (canvas.width - map[0].length * TILE_SIZE) / 2, offsetY = (canvas.height - map.length * TILE_SIZE) / 2; const worldX = gridPos.x * TILE_SIZE + offsetX + TILE_SIZE / 2, worldY = gridPos.y * TILE_SIZE + offsetY + TILE_SIZE / 2; return { x: worldX, y: worldY }; } }
        
        const levelMaps = [
            [ "WWWWWWWWWWWWWW WWWWWWWWWWWWWWW", "W P                          W", "W                            W", "W   WWW                      W", "W   W                        W", "W   W      WWWW              W", "W          W  W              W", "W                            W", "W               WWW          W", "                             ", "W                            W", "W   WWWWWW                   W", "W                            A", "W   WWWW                     W", "W      W                     W", "W      W   WWW               W", "W          W                 W", "W                            W", "WWWWWWWWWWWWWW WWWWWWWWWWWWWWW" ],
            [ "WWWWWWWWWWWWWW WWWWWWWWWWWWWWW", "W P                          W", "W   W   W   W   W   W   W    W", "W                            W", "W   W   W   W   W   W   W    W", "W                            W", "W   W   W   W   W   W   W    W", "W                            W", "W   W   W   W   W   W   W    W", "                             ", "W   W   W   W   W   W   W    W", "W                            W", "W   W   W   W   W   W   W    W", "W                            W", "W   W   W   W   W   W   W    W", "W                            W", "W                            A", "W                            W", "WWWWWWWWWWWWWW WWWWWWWWWWWWWWW" ],
            [ "WWWWWWWWWWWWWW WWWWWWWWWWWWWWW", "W P       W                  W", "W         W         WWWWWWW  W", "WWWWWWW   W                W W", "W       WWWWWWWWWW         W W", "W                          W W", "W         W                W W", "W   WWWWWWW       WWWWWW   W W", "W         W       W        W W", "                  W          ", "W   WWWWWWWWWWWWWWW        W W", "W   W                      W W", "W   W         WWWWWWWWWW   W W", "W   W                      W W", "W   WWWWWWWWWWWWWWWWWWWW   W W", "W                            W", "W                            W", "W                          A W", "WWWWWWWWWWWWWW WWWWWWWWWWWWWWW" ]
        ];

        function setupGame(difficultyKey, levelIndex) { player = null; ai = null; const map = levelMaps[levelIndex]; soundtrack.pause(); soundtrack.currentTime = 0; selectedDifficultyKey = difficultyKey; projectiles = []; obstacles = []; particles = []; explosions = []; explosiveBarrel = null; barrelRespawnTimer = 0; wallTextures.clear(); TILE_SIZE = Math.min(canvas.width / map[0].length, canvas.height / map.length); const offsetX = (canvas.width - map[0].length * TILE_SIZE) / 2, offsetY = (canvas.height - map.length * TILE_SIZE) / 2; const freePositions = []; pathfindingGrid = []; map.forEach((row, rowIndex) => { const gridRow = []; row.split('').forEach((cell, colIndex) => { const x = colIndex * TILE_SIZE + offsetX, y = rowIndex * TILE_SIZE + offsetY; if (cell === 'W') { obstacles.push({ x, y, width: TILE_SIZE, height: TILE_SIZE }); const texture = createBrickTexture(TILE_SIZE, TILE_SIZE); wallTextures.set(obstacles.length - 1, texture); gridRow.push(1); } else { gridRow.push(0); if (cell === ' ') freePositions.push({ x: x + TILE_SIZE / 2, y: y + TILE_SIZE / 2 }); } if (cell === 'P') player = new Tank(x + TILE_SIZE / 2, y + TILE_SIZE / 2, 'player', difficultyKey); if (cell === 'A') ai = new Tank(x + TILE_SIZE / 2, y + TILE_SIZE / 2, 'ai', difficultyKey); }); pathfindingGrid.push(gridRow); }); if (player) { player.lives = 3; player.isDestroyed = false; } if (freePositions.length > 0) { const randomPos = freePositions[Math.floor(Math.random() * freePositions.length)]; explosiveBarrel = { x: randomPos.x, y: randomPos.y, width: TILE_SIZE * 0.9, height: TILE_SIZE * 0.9, destroyed: false }; } gameState = 'playing'; }
        function restartGame() { soundtrack.pause(); victorySound.pause(); victorySound.currentTime = 0; propellerSound.pause(); currentLevelIndex = 0; gameState = 'title_start'; }
        function handleLevelAdvance() { currentLevelIndex++; if (currentLevelIndex < levelMaps.length) { gameState = 'level_cleared'; setTimeout(() => { setupGame(selectedDifficultyKey, currentLevelIndex); }, 3000); } else { gameState = 'gameWon'; soundtrack.pause(); if(audioUnlocked) victorySound.play(); } }
        function createExplosion(x, y) { if (audioUnlocked) boomSound.cloneNode().play(); explosions.push(new Explosion(x, y)); for (let i = 0; i < 40; i++) particles.push(new Particle(x, y, 'fire')); for (let i = 0; i < 20; i++) particles.push(new Particle(x, y, 'smoke')); for (let i = 0; i < 15; i++) particles.push(new Particle(x, y, 'debris')); const explosionRadius = 120; if (player && !player.isDestroyed) player.hit(); if (ai && !ai.isDestroyed) ai.hit(); }
        function createTankExplosion(x, y) { if (audioUnlocked) boomSound.cloneNode().play(); explosions.push(new Explosion(x, y)); setTimeout(() => explosions.push(new Explosion(x + Math.random()*40-20, y + Math.random()*40-20)), 200); for (let i = 0; i < 80; i++) particles.push(new Particle(x, y, 'fire')); for (let i = 0; i < 50; i++) particles.push(new Particle(x, y, 'smoke')); for (let i = 0; i < 40; i++) particles.push(new Particle(x, y, 'debris')); }
        function handleProjectiles() { for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; p.x += p.dx; p.y += p.dy; if (explosiveBarrel && !explosiveBarrel.destroyed && p.x > explosiveBarrel.x - explosiveBarrel.width/2 && p.x < explosiveBarrel.x + explosiveBarrel.width/2 && p.y > explosiveBarrel.y - explosiveBarrel.height/2 && p.y < explosiveBarrel.y + explosiveBarrel.height/2) { createExplosion(explosiveBarrel.x, explosiveBarrel.y); explosiveBarrel.destroyed = true; projectiles.splice(i, 1); continue; } const target = (p.owner === 'player') ? ai : player; if (target && !target.isDestroyed && Math.hypot(p.x - target.x, p.y - target.y) < target.width / 2) { target.hit(); projectiles.splice(i, 1); continue; } let hitWall = false; for (const o of obstacles) if (p.x > o.x && p.x < o.x + o.width && p.y > o.y && p.y < o.y + o.height) { hitWall = true; break; } if (hitWall) { projectiles.splice(i, 1); continue; } const buffer = 4; if (p.x < -buffer) p.x = canvas.width + buffer; if (p.x > canvas.width + buffer) p.x = -buffer; if (p.y < -buffer) p.y = canvas.height + buffer; if (p.y > canvas.height + buffer) p.y = -buffer; } }
        function spawnBarrel() { const map = levelMaps[currentLevelIndex]; const freePositions = []; const offsetX = (canvas.width - map[0].length * TILE_SIZE) / 2, offsetY = (canvas.height - map.length * TILE_SIZE) / 2; map.forEach((row, rowIndex) => { row.split('').forEach((cell, colIndex) => { const x = colIndex * TILE_SIZE + offsetX + TILE_SIZE / 2, y = rowIndex * TILE_SIZE + offsetY + TILE_SIZE / 2; if (cell === ' ' && player && ai && Math.hypot(player.x - x, player.y - y) > TILE_SIZE * 2 && Math.hypot(ai.x - x, ai.y - y) > TILE_SIZE * 2) freePositions.push({ x, y }); }); }); if (freePositions.length > 0) { const randomPos = freePositions[Math.floor(Math.random() * freePositions.length)]; explosiveBarrel = { x: randomPos.x, y: randomPos.y, width: TILE_SIZE * 0.9, height: TILE_SIZE * 0.9, destroyed: false }; } }
        function spawnCargoPlane() { cargoPlane = { x: -200, y: Math.random() * (canvas.height / 3) + 50, width: 150, height: 75, speed: 3, hasDropped: false, dropX: canvas.width * (0.4 + Math.random() * 0.4) }; if(audioUnlocked) { propellerSound.currentTime = 0; propellerSound.volume = 0; propellerSound.play(); } }
        function updateCargoPlane() { if (!cargoPlane) return; cargoPlane.x += cargoPlane.speed; if(audioUnlocked) { if(cargoPlane.x > 0 && cargoPlane.x < canvas.width * 0.8) { propellerSound.volume = Math.min(1, propellerSound.volume + 0.005); } else if (cargoPlane.x > canvas.width * 0.8) { propellerSound.volume = Math.max(0, propellerSound.volume - 0.01); } } if (!cargoPlane.hasDropped && cargoPlane.x > cargoPlane.dropX) { const map = levelMaps[currentLevelIndex]; const mapWidth = map[0].length * TILE_SIZE; const mapHeight = map.length * TILE_SIZE; const mapOffsetX = (canvas.width - mapWidth) / 2; const mapOffsetY = (canvas.height - mapHeight) / 2; supplyCrate = { x: cargoPlane.x + cargoPlane.width / 2, y: cargoPlane.y, targetX: cargoPlane.x + cargoPlane.width / 2, targetY: mapOffsetY + mapHeight/2 + (Math.random()-0.5) * mapHeight*0.8, scale: 0.1, fallProgress: 0, state: 'falling', rotation: 0 }; cargoPlane.hasDropped = true; } if (cargoPlane.x > canvas.width + cargoPlane.width) { cargoPlane = null; propellerSound.pause(); } }
        function updateSupplyCrate() { if (!supplyCrate) return; if (supplyCrate.state === 'falling') { supplyCrate.fallProgress += 0.02; supplyCrate.scale = 0.1 + supplyCrate.fallProgress * 0.9; supplyCrate.y = (cargoPlane ? cargoPlane.y : 0) + (supplyCrate.targetY - (cargoPlane ? cargoPlane.y : 0)) * supplyCrate.fallProgress; supplyCrate.rotation += 0.05; if (supplyCrate.fallProgress >= 1) { supplyCrate.state = 'landed'; supplyCrate.scale = 1.0; supplyCrate.y = supplyCrate.targetY; } } else if (supplyCrate.state === 'landed') { const checkCollisionWithTank = (tank) => { if (tank && !tank.isDestroyed && Math.hypot(tank.x - supplyCrate.targetX, tank.y - supplyCrate.targetY) < TILE_SIZE) { if (Math.random() < 0.5) { tank.lives = Math.min(5, tank.lives + 1); } else { tank.activateShield(); } supplyCrate = null; } }; checkCollisionWithTank(player); if(supplyCrate) checkCollisionWithTank(ai); } }
        function updateGame() { if(!player || !ai) return; planeFlyByTimer--; if (planeFlyByTimer <= 0) { spawnCargoPlane(); planeFlyByTimer = PLANE_FLYBY_INTERVAL; } updateCargoPlane(); updateSupplyCrate(); player.update(); ai.update(); handleProjectiles(); if (explosiveBarrel && explosiveBarrel.destroyed) { barrelRespawnTimer++; if (barrelRespawnTimer >= BARREL_RESPAWN_TIME) { spawnBarrel(); barrelRespawnTimer = 0; } } for (let i = particles.length - 1; i >= 0; i--) if (!particles[i].update()) particles.splice(i, 1); for (let i = explosions.length - 1; i >= 0; i--) { explosions[i].update(); if (!explosions[i].active) explosions.splice(i, 1); } }
        function createBrickTexture(width, height) { const tempCanvas = document.createElement('canvas'); tempCanvas.width = width; tempCanvas.height = height; const tempCtx = tempCanvas.getContext('2d'); tempCtx.fillStyle = '#8B7B6B'; tempCtx.fillRect(0, 0, width, height); for (let row = 0; row < Math.ceil(height / 12); row++) for (let col = 0; col < Math.ceil(width / 22); col++) { const brickX = col * 22 + (row % 2 ? 11 : 0), brickY = row * 12; if (brickX < width) { const brightness = 0.8 + Math.random() * 0.4; tempCtx.fillStyle = Math.random() > 0.3 ? `rgb(${Math.floor(210*brightness)}, ${Math.floor(180*brightness)}, ${Math.floor(140*brightness)})` : `rgb(${Math.floor(160*brightness)}, ${Math.floor(120*brightness)}, ${Math.floor(80*brightness)})`; tempCtx.fillRect(brickX, brickY, Math.min(20, width - brickX), 10); if (Math.random() > 0.7) { tempCtx.fillStyle = 'rgba(0,0,0,0.1)'; tempCtx.fillRect(brickX + 2, brickY + 2, Math.min(20, width - brickX) - 4, 6); } } } tempCtx.strokeStyle = 'rgba(0,0,0,0.3)'; tempCtx.lineWidth = 1; tempCtx.strokeRect(1, 1, width - 2, height - 2); return tempCanvas; }
        
        function drawGame() { if(!player || !ai) return; ctx.fillStyle = '#4a5443'; ctx.fillRect(0, 0, canvas.width, canvas.height); if (supplyCrate) { const size = TILE_SIZE * supplyCrate.scale; ctx.beginPath(); ctx.ellipse(supplyCrate.targetX, supplyCrate.targetY, size / 2, size / 4, 0, 0, Math.PI * 2); ctx.fillStyle = `rgba(0,0,0,${0.4 * supplyCrate.fallProgress})`; ctx.fill(); ctx.save(); ctx.translate(supplyCrate.x, supplyCrate.y); ctx.rotate(supplyCrate.rotation); ctx.drawImage(crateImage, -size / 2, -size / 2, size, size); ctx.restore(); } obstacles.forEach((o, index) => { const texture = wallTextures.get(index); if (texture) ctx.drawImage(texture, o.x, o.y); }); if (explosiveBarrel && !explosiveBarrel.destroyed && barrelImage.complete) { const barrelSize = TILE_SIZE * 0.9; ctx.drawImage(barrelImage, explosiveBarrel.x - barrelSize/2, explosiveBarrel.y - barrelSize/2, barrelSize, barrelSize); } if (explosiveBarrel && explosiveBarrel.destroyed && barrelRespawnTimer > 0) { const remainingTime = Math.ceil((BARREL_RESPAWN_TIME - barrelRespawnTimer) / 60); ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(`Neues Fass in ${remainingTime}s`, canvas.width / 2, 50); } player.draw(); ai.draw(); projectiles.forEach(p => { ctx.fillStyle = '#FFD700'; ctx.fillRect(p.x - 2, p.y - 2, 4, 4); }); explosions.forEach(exp => exp.draw()); particles.forEach(p => p.draw()); if(cargoPlane) { ctx.drawImage(cargoImage, cargoPlane.x, cargoPlane.y, cargoPlane.width, cargoPlane.height); } drawHUD(); }
        function drawTitleScreen() { ctx.drawImage(titleImage, 0, 0, canvas.width, canvas.height); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = "white"; ctx.font = "bold 72px sans-serif"; ctx.textAlign = "center"; ctx.shadowColor = "black"; ctx.shadowBlur = 10; ctx.fillText("Panzer Duell", canvas.width / 2, canvas.height / 2 - 120); ctx.shadowBlur = 0; if (gameState === 'title_start') { const button = startButton, isHover = mouse.hoverButton === button; ctx.fillStyle = isHover ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.7)'; ctx.fillRect(button.x, button.y, button.w, button.h); ctx.strokeStyle = "white"; ctx.lineWidth = isHover ? 4 : 2; ctx.strokeRect(button.x, button.y, button.w, button.h); ctx.fillStyle = "black"; ctx.font = "bold 32px sans-serif"; ctx.fillText(button.text, button.x + button.w / 2, button.y + 45); } else if (gameState === 'title_select') { const alpha = Math.min(1.0, (Date.now() - animationStartTime) / animationDuration); ctx.globalAlpha = alpha; ctx.font = "30px sans-serif"; ctx.fillStyle = "white"; ctx.fillText("Schwierigkeitsgrad wählen:", canvas.width / 2, canvas.height / 2); difficultyButtons.forEach(button => { const isHover = mouse.hoverButton === button; ctx.fillStyle = isHover ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.4)'; ctx.fillRect(button.x, button.y, button.w, button.h); ctx.strokeStyle = difficulties[button.difficulty].color; ctx.lineWidth = isHover ? 4 : 2; ctx.strokeRect(button.x, button.y, button.w, button.h); ctx.fillStyle = difficulties[button.difficulty].color; ctx.font = "bold 24px sans-serif"; ctx.fillText(button.text, button.x + button.w / 2, button.y + 35); }); ctx.globalAlpha = 1.0; } }
        function drawHUD() { if(!player) return; const lifeIconSize = 35; for(let i = 0; i < player.lives; i++) ctx.drawImage(playerImage, 10 + i * (lifeIconSize + 5), 10, lifeIconSize, lifeIconSize); ctx.filter = 'hue-rotate(180deg) brightness(1.2)'; if (ai) for(let i = 0; i < ai.lives; i++) ctx.drawImage(aiImage, canvas.width - (lifeIconSize + 10) - (i * (lifeIconSize + 5)), 10, lifeIconSize, lifeIconSize); ctx.filter = 'none'; }
        function drawGameOver() { const win = player && !player.isDestroyed; ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = win ? "#7CFC00" : "#DC143C"; ctx.font = "bold 60px sans-serif"; ctx.textAlign = "center"; ctx.fillText(win ? "Du hast gewonnen!" : "Game Over", canvas.width / 2, canvas.height / 2 - 20); ctx.fillStyle = "white"; ctx.font = "30px sans-serif"; ctx.fillText("Klicken zum Neustarten", canvas.width / 2, canvas.height / 2 + 30); }
        function drawLevelClearedScreen() { updateGame(); drawGame(); ctx.fillStyle = "rgba(0, 0, 0, 0.7)"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = "#FFD700"; ctx.font = "bold 60px sans-serif"; ctx.textAlign = "center"; ctx.fillText(`Level ${currentLevelIndex} geschafft!`, canvas.width / 2, canvas.height / 2 - 20); ctx.fillStyle = "white"; ctx.font = "30px sans-serif"; ctx.fillText(`Nächstes Level startet...`, canvas.width / 2, canvas.height / 2 + 30); }
        function drawGameWonScreen() { ctx.drawImage(victoryImage, 0, 0, canvas.width, canvas.height); ctx.fillStyle = "rgba(0, 0, 0, 0.4)"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = "#FFD700"; ctx.font = "bold 70px sans-serif"; ctx.textAlign = "center"; ctx.shadowColor = "black"; ctx.shadowBlur = 10; ctx.fillText("SIEGER!", canvas.width / 2, canvas.height / 2 - 40); ctx.fillStyle = "white"; ctx.font = "30px sans-serif"; ctx.shadowBlur = 5; ctx.fillText(`Alle ${levelMaps.length} Level geschafft!`, canvas.width / 2, canvas.height / 2 + 20); ctx.fillText("Klicken zum Neustarten", canvas.width / 2, canvas.height / 2 + 70); ctx.shadowBlur = 0; }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (gameState.startsWith('title')) drawTitleScreen();
            else if (gameState === 'playing') { updateGame(); drawGame(); }
            else if (gameState === 'gameOver') { updateGame(); drawGame(); drawGameOver(); }
            else if (gameState === 'level_cleared') { updateGame(); drawLevelClearedScreen(); }
            else if (gameState === 'gameWon') { drawGameWonScreen(); }
            requestAnimationFrame(gameLoop);
        }
        function handleMouseClick(e) {
            if (gameState === 'title_start' && mouse.hoverButton === startButton) {
                if (!audioUnlocked) {
                    Promise.all([shootSound.play(), soundtrack.play(), boomSound.play(), victorySound.play(), propellerSound.play(), shieldHitSound.play()]).then(() => {
                        shootSound.pause(); soundtrack.play(); boomSound.pause(); victorySound.pause(); propellerSound.pause(); shieldHitSound.pause();
                    }).catch(console.error);
                    audioUnlocked = true;
                } else { soundtrack.play(); }
                animationStartTime = Date.now(); gameState = 'title_select';
            } else if (gameState === 'title_select' && mouse.hoverButton && difficultyButtons.includes(mouse.hoverButton)) {
                currentLevelIndex = 0;
                setupGame(mouse.hoverButton.difficulty, currentLevelIndex);
            } else if (gameState === 'gameOver' || gameState === 'gameWon') {
                restartGame();
            }
        }
        function handleMouseMove(e) { const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; mouse.hoverButton = null; let buttons = (gameState === 'title_start') ? [startButton] : (gameState === 'title_select') ? difficultyButtons : null; if (buttons) for(const button of buttons) if (mouse.x > button.x && mouse.x < button.x + button.w && mouse.y > button.y && mouse.y < button.y + button.h) mouse.hoverButton = button; }
        function resizeCanvas() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            startButton.x = (canvas.width - startButton.w) / 2; startButton.y = canvas.height / 2 + 40;
            const btnW = 200, btnH = 60, spacing = 30, totalW = (btnW * 3) + (spacing * 2);
            const startX = (canvas.width - totalW) / 2, startY = canvas.height / 2 + 50;
            difficultyButtons.length = 0; let i = 0;
            for (const key in difficulties) { difficultyButtons.push({ x: startX + i * (btnW + spacing), y: startY, w: btnW, h: btnH, text: difficulties[key].name, difficulty: key }); i++; }
            if(gameState === 'playing' || gameState === 'gameOver' || gameState === 'level_cleared') setupGame(selectedDifficultyKey, currentLevelIndex);
        }
        let imagesLoaded = 0; const totalImages = 8;
        const onImageLoad = () => { if (++imagesLoaded === totalImages) { resizeCanvas(); gameLoop(); } };
        window.addEventListener('resize', resizeCanvas);
        playerImage.onload = onImageLoad; aiImage.onload = onImageLoad;
        titleImage.onload = onImageLoad; barrelImage.onload = onImageLoad;
        victoryImage.onload = onImageLoad; cargoImage.onload = onImageLoad;
        crateImage.onload = onImageLoad; shieldImage.onload = onImageLoad;
    </script>
</body>
</html>